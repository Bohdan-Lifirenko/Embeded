### **C code:**
```
int counter = 0;

int main(void) {
    while (counter < 21) {
			++counter;
		}

    return 0;
}
```

### **Part of machine code:**
```
0x000004CA E7FF      B             0x000004CC
0x000004CC F2400060  MOVW          r0,#0x60
0x000004D0 F2C20000  MOVT          r0,#0x2000
0x000004D4 6800      LDR           r0,[r0,#0x00]
0x000004D6 2814      CMP           r0,#0x14
0x000004D8 DC08      BGT           0x000004EC
0x000004DA E7FF      B             0x000004DC
```

---

Ось що робить кожна інструкція, пояснено простими словами та з виправленням помилок у формулюванні вашого запитання:

### **1) `B 0x000004CC`**

Безумовний перехід (branch).
Процесор просто стрибає на адресу **0x000004CC** і продовжує виконання звідти.

---

### **2) `MOVW r0, #0x60`**

Завантажує **молодші 16 біт** значення в регістр **r0**.
Після цієї інструкції в r0 буде:

```
r0 = 0x0060
```

---

### **3) `MOVT r0, #0x2000`**

Завантажує **старші 16 біт** у регістр **r0**, не змінюючи молодші.

Комбінація інструкцій 2 і 3 створює повне 32-бітове число:

```
r0 = 0x20000060
```

Це адреса в **SRAM** мікроконтролера (пам'ять починається з 0x2000 0000).

---

### **4) `LDR r0, [r0, #0x00]`**

Завантажує слово (32 біти) з оперативної пам’яті за адресою:

```
r0 = * (uint32_t*)(0x20000060)
```

Тобто r0 тепер містить значення, яке лежить у комірці пам’яті **0x20000060**.

---

### **5) `CMP r0, #0x14`**

Порівнює значення у r0 з **20 (0x14)**.

---

### **6) `BGT 0x000004EC`**

Перехід, якщо r0 **більше за** 0x14.

* Якщо `r0 > 20` → стрибок на адресу **0x000004EC**.
* Якщо `r0 ≤ 20` → виконання продовжується далі по коду.

---

## **Підсумок логіки**

Код:

1. Формує адресу `0x20000060`
2. Зчитує значення з цієї адреси в r0
3. Порівнює значення з **20**
4. Якщо значення більше — переходить на **0x000004EC**

### Тобто це перевірка змінної в RAM:

```
if (*(uint32_t*)0x20000060 > 20) {
    goto 0x000004EC;
}
```

Якщо хочете, можу розшифрувати також байтовий машинний код або показати, як це виглядає у С.
