Різні рівні оптимізації компілятора керують тим, **наскільки агресивно компілятор перебудовує твій код**, щоб зробити його:

* швидшим
* меншим
* ефективнішим

Рівні оптимізації — це зазвичай **-O0, -O1, -O2, -O3, -Os, -Ofast** (в GCC/Clang; в IAR/Keil схоже, але з іншими позначеннями).

Нижче детально і просто.

---

# **O0 — Без оптимізації**

* Програма майже відповідає початковому коду.
* Кожен рядок коду → майже один набір інструкцій.
* Дуже зручно **дебажити**, бо все передбачувано.
* Генерує **найбільший і найповільніший** код.

**Використання:** коли ти налагоджуєш програму.

---

# **O1 — Легка оптимізація**

* Прибирає очевидні зайві операції.
* Трохи переставляє інструкції.
* Трохи оптимізує цикли та логіку.

Зараз код стає:

* швидшим
* меншим
* все ще досить легким для дебагу, але іноді інструкції вже не співпадають зі строками.

---

# **O2 — Сильні оптимізації**

Інтенсивніші перетворення:

* Розкручування циклів (**loop unrolling**)
* Вилучення мертвого коду (**dead-code elimination**)
* Скорочення доступів до пам’яті
* Присвоєння значень у регістри
* Inline підпрограм (**function inlining**)
* Аналіз залежностей між інструкціями

**Зазвичай O2 — найкращий вибір для embedded**, бо:

* швидкий код
* розумний розмір
* безпечний (не ламає стандартні правила)

---

# **O3 — Максимальна продуктивність**

Що додається до O2:

* ще більше inline
* агресивна оптимізація циклів
* спекулятивні перетворення коду
* складні міжфункціональні оптимізації

Може створювати:

* більший код
* інколи повільніший (!) через кеш
* складніший дебаг
* потенційні побічні ефекти, якщо код залежить від таймінгу (типово в embedded)

---

# **Os — Оптимізація на мінімальний розмір**

* Розкручування циклів майже не робиться
* Мінімум inline
* Прибираються зайві інструкції
* Код компактніший, але іноді повільніший

Чудово для embedded, де важлива:

* флеш-пам’ять
* RAM

---

# **Ofast — агресивний режим (може порушувати стандарти C)**

Додає:

* порушення strict IEEE правил для float
* спрощення математичних функцій
* радикальні оптимізації циклів
* припущення, що всі змінні не накладаються в пам’яті (**strict aliasing**)

Може прискорити код, але:

* може ламати коректність коду
* може створювати баги, особливо в embedded

---

# **Як рівні оптимізації впливають на embedded?**

### Збільшення оптимізації змінює:

* передбачуваність таймінгів
* відповідність між С-кодом і асемблером
* місце розташування змінних
* порядок інструкцій
* поведінку volatile

Для периферії (GPIO, UART, Timer) часто необхідно вказувати **volatile**, інакше компілятор може прибрати читання/запис.

---

# **Коротке резюме**

| Рівень | Швидкість   | Розмір коду | Дебаг      | Безпека          |
| ------ | ----------- | ----------- | ---------- | ---------------- |
| O0     | низька      | найбільший  | найкращий  | безпечний        |
| O1     | трохи ↑     | менший      | нормальний | безпечний        |
| O2     | висока      | менший      | складніше  | безпечний        |
| O3     | дуже висока | більший     | важко      | інколи ризиковий |
| Os     | помірна     | найменший   | нормальний | безпечний        |
| Ofast  | дуже висока | різний      | важко      | ризиковий        |

---

Хочеш, поясню **на прикладі твого коду** як змінюється асемблер при різних рівнях оптимізації?
